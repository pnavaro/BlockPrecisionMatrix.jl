var documenterSearchIndex = {"docs":
[{"location":"original_r_program/#Function-estimating-the-precision-matrix-with-the-method-from-Xia-et-al-(code-Madison)","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function estimating the precision matrix with the method from Xia et al (code Madison)","text":"","category":"section"},{"location":"original_r_program/","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function estimating the precision matrix with the method from Xia et al (code Madison)","text":"library(glmnet)\n\nPrecXia = function(X){\n  n = nrow(X)\n  betahat = matrix(0,ncol(X)-1,ncol(X))\n  reshat  = X\n  for (k in 1:ncol(X)){\n    fitreg  = glmnet(X[,-k],X[,k],family=\"gaussian\",lambda = 2*sqrt(var(X[,k])*log(ncol(X))/nrow(X)),standardize = FALSE) \n    betahat[,k] = as.vector(fitreg$beta)\n    reshat[,k]  = X[,k]-as.vector(predict(fitreg,X[,-k]))\n  }\n  rtilde = cov(reshat)*(n-1)/n\n  rhat   = rtilde\n  for (i in 1:(ncol(X)-1)){\n    for (j in (i+1):ncol(X)){\n      rhat[i,j] = -(rtilde[i,j]+rtilde[i,i]*betahat[i,j]+rtilde[j,j]*betahat[j-1,i])\n      rhat[j,i] = rhat[i,j]\n    }\n  }\n  Tprec  = 1/rhat\n  TprecStd = Tprec\n  for (i in 1:(ncol(X)-1)){\n    for (j in (i+1):ncol(X)){\n      Tprec[i,j] = Tprec[j,i] = rhat[i,j]/(rhat[i,i]*rhat[j,j])\n      thetahatij = (1+(betahat[i,j]^2*rhat[i,i]/rhat[j,j]))/(n*rhat[i,i]*rhat[j,j])   \n      TprecStd[i,j] = TprecStd[j,i] = Tprec[i,j]/sqrt(thetahatij)\n    }\n  }\n  \n  MatPrecXia = list(Tprec=Tprec,TprecStd=TprecStd)\n}","category":"page"},{"location":"original_r_program/#Function-performing-the-test-on-blocks-and-adjusting-the-results","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function performing the test on blocks and adjusting the results","text":"","category":"section"},{"location":"original_r_program/","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function estimating the precision matrix with the method from Xia et al (code Madison)","text":"inputs:\ndata: data matrix (n*p) where n is the sample size and p the number of grid points (for now. it will be spline coefficients?)\nblocks: vector of length p containing block indexes (numeric, from 1 to number of blocks) for each grid point\nB: number of permutations done to evaluate the tests p-values","category":"page"},{"location":"original_r_program/","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function estimating the precision matrix with the method from Xia et al (code Madison)","text":"IWT_Block_precision <- function(data,blocks,B=1000,estimation='SCAD'){  \n  \n  n <- dim(data)[1]\n  p = dim(data)[2]\n  nblocks = length(levels(factor(blocks)))\n  \n  stat.test = function(block1.perm,block2,data.orig,points.x,points.y){\n    data.orig[,points.x] = block1.perm\n    PrecMat = PrecXia(data.orig)\n    #Rhohat = cor(block1,block2,method='pearson')\n    #Rohat.std = Rhohat^2/(1-Rhohat^2)\n    submat = PrecMat$TprecStd[points.x,points.y]\n    return(sum(submat)^2) # We use the Xia estimator for the precision matrix\n  }\n  \n  # Permutation test:\n  #T_coeff <- array(dim=c(B,p,p)) # permuted test statistics\n  permute = function(x,n){\n    permutation = sample(n)\n    result = x[permutation,] \n    return(result) \n  }\n  permute.conditional = function(y,n,data.complement,estimation){ # uses SCAD/OLS\n    permutation = sample(n)\n    \n    # SCAD/OLS estimaytion\n    fitted = switch(estimation, \n                    LM=lm.fit(cbind(1,data.complement),y)$fitted,\n                    SCAD=apply(y,2,SCADmod,x=data.complement,lambda=2*sqrt(var(y[,1])*log(ncol(data.complement))/nrow(data.complement))))\n    \n    residuals = y - fitted\n    \n    result = fitted + residuals[permutation,]\n    return(result) \n  }\n  \n  \n  # tests on rectangles\n  pval_array = array(dim=c(2,p,p))\n  corrected.pval = matrix(0,nrow=p,ncol=p)\n  seeds = round(runif(B,0,1000000))\n  \n  responsible.test = matrix(nrow=p,ncol=p)\n  ntests.blocks = zeromatrix = matrix(0,nrow=p,ncol=p)\n  \n  # For parallelization: the loops are independent between each other, so they can be easily parallelized. \n  # The only point to pay attention to is that for computing the adjusted p-value, the maximization is done at the end of each loop.\n  # It would also be possible to save all the results of each loop instead (in an array) and do the maximization only once at the end.\n  for(ix in 2:nblocks){ # x coordinate starting point. \n    for(lx in 0:(nblocks-ix)){ # length on x axis of the rectangle\n      index.x = ix:(ix+lx) # index first block\n      points.x = which(blocks %in% index.x) # coefficients in block index.x\n      data.B1 = data[,points.x] # data of the first block\n      \n      data.B1.array = array(data=data.B1,dim=c(n,dim(data.B1)[2],B)) # tableau de copies de data.B1\n      data.B1.list = lapply(seq(dim(data.B1.array)[3]), function(x) data.B1.array[ , , x]) # liste de copies de data.B1\n      \n      for(iy in 1:(ix-1)){ # y coordinate starting point. stops before the diagonal\n        for(ly in 0:(ix-iy-1)){ # length on y axis of the rectangle\n          # data of the second block\n          index.y = iy:(iy+ly) # index second block\n          points.y = which(blocks %in% index.y)\n          data.B2 = data[,points.y]\n          \n          index.complement = (1:nblocks)[-c(index.x,index.y)]\n          points.complement = which(blocks %in% index.complement)\n          data.complement = data[,points.complement]\n          \n          # print(paste0('x:',index.x))\n          # print(paste0('y:',index.y))\n          # print(paste0('c:', index.complement))\n          \n          # permuted data of the first block\n          ncol = dim(data.complement)[2]\n          \n          if(ncol > 0){\n            # A chaque élément de la liste de copies de data.B1.list, \n            # on applique permute.conditional\n            data.B1.perm.l = lapply(data.B1.list,permute.conditional,n=n,data.complement=data.complement,estimation=estimation)\n          }else{\n            data.B1.perm.l = lapply(data.B1.list,permute,n=n)\n          }\n          \n          data.B1.perm = simplify2array(data.B1.perm.l)\n\n          testmatrix = zeromatrix\n          testmatrix[points.x,points.y] = 1\n          ntests.blocks = ntests.blocks + testmatrix\n          image.plot(ntests.blocks,main=paste0('Blocks: ',index.x,'-',index.y))\n          image.plot(testmatrix,main=paste0('Blocks: ',index.x,'-',index.y))\n          # Estimation de la statistique de test pour les 2 blocs considérés\n          T0.tmp = stat.test(data.B1,data.B2,data.orig=data,points.x=points.x,points.y=points.y)\n          # Estimation de la statistique de test pour chacune des parmutations\n          Tperm.tmp = apply(data.B1.perm,3,stat.test,block2=data.B2,data.orig=data,points.x=points.x,points.y=points.y)\n          # calcul de la p-value\n          pval.tmp = mean(Tperm.tmp >= T0.tmp)\n\n          corrected.pval_temp = matrix(0,nrow=p,ncol=p)\n          corrected.pval_temp[points.x,points.y] = pval.tmp\n          corrected.pval_temp[points.y,points.x] = pval.tmp # simmetrization\n          \n          pval_array[1,,] = corrected.pval # old adjusted p-value\n          pval_array[2,,] = corrected.pval_temp # p-value resulting from the test of this block\n\n          corrected.pval = apply(pval_array,c(2,3),max) # maximization for updating the adjusted p-value\n\n          index = apply(pval_array,c(2,3),which.max)\n          responsible.test[which(index==2)] = paste0(paste0(index.x,collapse=','),'-',paste0(index.y,collapse=','))\n        }\n      }\n    }\n  }\n  return(list(corrected.pval=corrected.pval,responsible.test=responsible.test,ntests.blocks=ntests.blocks))\n}\n","category":"page"},{"location":"#BlockPrecisionMatrix.jl","page":"Home","title":"BlockPrecisionMatrix.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Visual Explanation of Statistical Testing","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the animation above, they illustrate a test on the mean. In our case, we want to apply the ideas of permutation tests (inverse of the covariance matrix) but to identify the null blocks of a precision matrix. A block will be null in the following situation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider the blocks associated with the variables X and Y of a data set D such that","category":"page"},{"location":"","page":"Home","title":"Home","text":"D = (XYZ) with X in R^np_X Y in R^np_Y Z in R^np_Z","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nX  = beta_X 1Z + epsilon_X \nY  = beta_Y 1Z + epsilon_Y\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"then the block P_XY is null if epsilon_X and epsilon_Y are independent ie if the correlation matrix of epsilon_X with epsilon_Y is null.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So we apply the permutations to the residues epsilon_X and/or epsilon_Y. To do this, we first need to estimate the linear model (this is where we use the SCAD estimation), recover the residuals, permute them and then reconstruct the data corresponding to the permuted residuals with permute_scad.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To finish the test, we need to estimate the precision matrices associated with the permutations. We use the callable type StatTest.","category":"page"},{"location":"#BlockPrecisionMatrix.permute_scad","page":"Home","title":"BlockPrecisionMatrix.permute_scad","text":"permute_scad(rng, Y, Z)\n\nReconstruct the data corresponding to the permuted residuals esimated  with SCAD regression.\n\n\n\n\n\n","category":"function"},{"location":"#BlockPrecisionMatrix.StatTest","page":"Home","title":"BlockPrecisionMatrix.StatTest","text":"StatTest(n, p)\n\nWe use the Xia estimator for the precision matrix\n\n\n\n\n\n","category":"type"},{"location":"#BlockPrecisionMatrix.cov_simu","page":"Home","title":"BlockPrecisionMatrix.cov_simu","text":"cov_simu(rng, blocs, indblocs, blocs_on, D)\n\nfonction pour simuler des matrices de covariances avec blocs\n\nblocs    : indice des intervalles separant les blocs (sortie de StructureCov)\nindblocs : liste des indices des blocs (sortie de StructureCov)\nblocs_on  : liste des indices des couples de blocs \"allumes\"\nD        : vecteur des valeurs propres de la matrice a simuler\n\n\n\n\n\n","category":"function"},{"location":"#BlockPrecisionMatrix.structure_cov","page":"Home","title":"BlockPrecisionMatrix.structure_cov","text":"structure_cov(rng, p, b, blocs_on)\n\nFonction pour definir les indices des blocs\n\np : dimension des donnees\nb : nombre de blocs\nblocs_on : liste des indices des couples de blocs \"allumes\"\n\n\n\n\n\n","category":"function"},{"location":"#BlockPrecisionMatrix.generate_data","page":"Home","title":"BlockPrecisionMatrix.generate_data","text":"generate_data(rng, p, n, b, blocs_on )\n\nCreate the simulation data and returning the covariance matrix and prediction matrix with blocks.\n\nExample\n\nusing Random\nusing UnicodePlots\nimport BlockPrecisionMatrix.generate_data\n\np = 10 \nn = 500\nb = 3\nrng = MersenneTwister(12)\nblocs_on  = [[1,3]]\n\ncovmat, premat, data, blocks = generate_data(rng, p, n, b, blocs_on)\n\ndisplay(heatmap(covmat, title=\"covmat\"))\ndisplay(heatmap(premat, title=\"premat\"))\n\n\n\n\n\n","category":"function"},{"location":"#BlockPrecisionMatrix.permute","page":"Home","title":"BlockPrecisionMatrix.permute","text":"permute(rng, x, n)\n\nPermutation\n\n\n\n\n\n","category":"function"},{"location":"#BlockPrecisionMatrix.iwt_block_precision","page":"Home","title":"BlockPrecisionMatrix.iwt_block_precision","text":"iwt_block_precision(data, blocks; B=1000, estimation=:SCAD)\n\nfunction performing the test on blocks and adjusting the results\n\ndata: data matrix (n*p) where n is the sample size and p the number of grid points (for now. it will be spline coefficients?)\nblocks: vector of length p containing block indexes (numeric, from 1 to number of blocks) for each grid point\nB: number of permutations done to evaluate the tests p-values\n\n\n\n\n\n","category":"function"}]
}
