var documenterSearchIndex = {"docs":
[{"location":"original_r_program/#Function-estimating-the-precision-matrix-with-the-method-from-Xia-et-al-(code-Madison)","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function estimating the precision matrix with the method from Xia et al (code Madison)","text":"","category":"section"},{"location":"original_r_program/","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function estimating the precision matrix with the method from Xia et al (code Madison)","text":"library(glmnet)\n\nPrecXia = function(X){\n  n = nrow(X)\n  betahat = matrix(0,ncol(X)-1,ncol(X))\n  reshat  = X\n  for (k in 1:ncol(X)){\n    fitreg  = glmnet(X[,-k],X[,k],family=\"gaussian\",lambda = 2*sqrt(var(X[,k])*log(ncol(X))/nrow(X)),standardize = FALSE) \n    betahat[,k] = as.vector(fitreg$beta)\n    reshat[,k]  = X[,k]-as.vector(predict(fitreg,X[,-k]))\n  }\n  rtilde = cov(reshat)*(n-1)/n\n  rhat   = rtilde\n  for (i in 1:(ncol(X)-1)){\n    for (j in (i+1):ncol(X)){\n      rhat[i,j] = -(rtilde[i,j]+rtilde[i,i]*betahat[i,j]+rtilde[j,j]*betahat[j-1,i])\n      rhat[j,i] = rhat[i,j]\n    }\n  }\n  Tprec  = 1/rhat\n  TprecStd = Tprec\n  for (i in 1:(ncol(X)-1)){\n    for (j in (i+1):ncol(X)){\n      Tprec[i,j] = Tprec[j,i] = rhat[i,j]/(rhat[i,i]*rhat[j,j])\n      thetahatij = (1+(betahat[i,j]^2*rhat[i,i]/rhat[j,j]))/(n*rhat[i,i]*rhat[j,j])   \n      TprecStd[i,j] = TprecStd[j,i] = Tprec[i,j]/sqrt(thetahatij)\n    }\n  }\n  \n  MatPrecXia = list(Tprec=Tprec,TprecStd=TprecStd)\n}","category":"page"},{"location":"original_r_program/#Function-performing-the-test-on-blocks-and-adjusting-the-results","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function performing the test on blocks and adjusting the results","text":"","category":"section"},{"location":"original_r_program/","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function estimating the precision matrix with the method from Xia et al (code Madison)","text":"inputs:\ndata: data matrix (n*p) where n is the sample size and p the number of grid points (for now. it will be spline coefficients?)\nblocks: vector of length p containing block indexes (numeric, from 1 to number of blocks) for each grid point\nB: number of permutations done to evaluate the tests p-values","category":"page"},{"location":"original_r_program/","page":"Function estimating the precision matrix with the method from Xia et al (code Madison)","title":"Function estimating the precision matrix with the method from Xia et al (code Madison)","text":"IWT_Block_precision <- function(data,blocks,B=1000,estimation='SCAD'){  \n  \n  n <- dim(data)[1]\n  p = dim(data)[2]\n  nblocks = length(levels(factor(blocks)))\n  \n  stat.test = function(block1.perm,block2,data.orig,points.x,points.y){\n    data.orig[,points.x] = block1.perm\n    PrecMat = PrecXia(data.orig)\n    #Rhohat = cor(block1,block2,method='pearson')\n    #Rohat.std = Rhohat^2/(1-Rhohat^2)\n    submat = PrecMat$TprecStd[points.x,points.y]\n    return(sum(submat)^2) # We use the Xia estimator for the precision matrix\n  }\n  \n  # Permutation test:\n  #T_coeff <- array(dim=c(B,p,p)) # permuted test statistics\n  permute = function(x,n){\n    permutation = sample(n)\n    result = x[permutation,] \n    return(result) \n  }\n  permute.conditional = function(y,n,data.complement,estimation){ # uses SCAD/OLS\n    permutation = sample(n)\n    \n    # SCAD/OLS estimaytion\n    fitted = switch(estimation, \n                    LM=lm.fit(cbind(1,data.complement),y)$fitted,\n                    SCAD=apply(y,2,SCADmod,x=data.complement,lambda=2*sqrt(var(y[,1])*log(ncol(data.complement))/nrow(data.complement))))\n    \n    residuals = y - fitted\n    \n    result = fitted + residuals[permutation,]\n    return(result) \n  }\n  \n  \n  # tests on rectangles\n  pval_array = array(dim=c(2,p,p))\n  corrected.pval = matrix(0,nrow=p,ncol=p)\n  seeds = round(runif(B,0,1000000))\n  \n  responsible.test = matrix(nrow=p,ncol=p)\n  ntests.blocks = zeromatrix = matrix(0,nrow=p,ncol=p)\n  \n  # For parallelization: the loops are independent between each other, so they can be easily parallelized. \n  # The only point to pay attention to is that for computing the adjusted p-value, the maximization is done at the end of each loop.\n  # It would also be possible to save all the results of each loop instead (in an array) and do the maximization only once at the end.\n  for(ix in 2:nblocks){ # x coordinate starting point. \n    for(lx in 0:(nblocks-ix)){ # length on x axis of the rectangle\n      index.x = ix:(ix+lx) # index first block\n      points.x = which(blocks %in% index.x) # coefficients in block index.x\n      data.B1 = data[,points.x] # data of the first block\n      \n      data.B1.array = array(data=data.B1,dim=c(n,dim(data.B1)[2],B)) # tableau de copies de data.B1\n      data.B1.list = lapply(seq(dim(data.B1.array)[3]), function(x) data.B1.array[ , , x]) # liste de copies de data.B1\n      \n      for(iy in 1:(ix-1)){ # y coordinate starting point. stops before the diagonal\n        for(ly in 0:(ix-iy-1)){ # length on y axis of the rectangle\n          # data of the second block\n          index.y = iy:(iy+ly) # index second block\n          points.y = which(blocks %in% index.y)\n          data.B2 = data[,points.y]\n          \n          index.complement = (1:nblocks)[-c(index.x,index.y)]\n          points.complement = which(blocks %in% index.complement)\n          data.complement = data[,points.complement]\n          \n          # print(paste0('x:',index.x))\n          # print(paste0('y:',index.y))\n          # print(paste0('c:', index.complement))\n          \n          # permuted data of the first block\n          ncol = dim(data.complement)[2]\n          \n          if(ncol > 0){\n            # A chaque élément de la liste de copies de data.B1.list, \n            # on applique permute.conditional\n            data.B1.perm.l = lapply(data.B1.list,permute.conditional,n=n,data.complement=data.complement,estimation=estimation)\n          }else{\n            data.B1.perm.l = lapply(data.B1.list,permute,n=n)\n          }\n          \n          data.B1.perm = simplify2array(data.B1.perm.l)\n\n          testmatrix = zeromatrix\n          testmatrix[points.x,points.y] = 1\n          ntests.blocks = ntests.blocks + testmatrix\n          image.plot(ntests.blocks,main=paste0('Blocks: ',index.x,'-',index.y))\n          image.plot(testmatrix,main=paste0('Blocks: ',index.x,'-',index.y))\n          # Estimation de la statistique de test pour les 2 blocs considérés\n          T0.tmp = stat.test(data.B1,data.B2,data.orig=data,points.x=points.x,points.y=points.y)\n          # Estimation de la statistique de test pour chacune des parmutations\n          Tperm.tmp = apply(data.B1.perm,3,stat.test,block2=data.B2,data.orig=data,points.x=points.x,points.y=points.y)\n          # calcul de la p-value\n          pval.tmp = mean(Tperm.tmp >= T0.tmp)\n\n          corrected.pval_temp = matrix(0,nrow=p,ncol=p)\n          corrected.pval_temp[points.x,points.y] = pval.tmp\n          corrected.pval_temp[points.y,points.x] = pval.tmp # simmetrization\n          \n          pval_array[1,,] = corrected.pval # old adjusted p-value\n          pval_array[2,,] = corrected.pval_temp # p-value resulting from the test of this block\n\n          corrected.pval = apply(pval_array,c(2,3),max) # maximization for updating the adjusted p-value\n\n          index = apply(pval_array,c(2,3),which.max)\n          responsible.test[which(index==2)] = paste0(paste0(index.x,collapse=','),'-',paste0(index.y,collapse=','))\n        }\n      }\n    }\n  }\n  return(list(corrected.pval=corrected.pval,responsible.test=responsible.test,ntests.blocks=ntests.blocks))\n}\n","category":"page"},{"location":"#BlockPrecisionMatrix.jl","page":"Home","title":"BlockPrecisionMatrix.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BlockPrecisionMatrix.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Explication animée du principe des tests par permutations","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dans l'animation, ils illustrent un test sur la moyenne. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dans notre cas, on veut appliquer les idées des tests par permutation (inverse de la matrice de covariance) mais pour identifier les blocs nuls d'une matrice de précision. Un bloc sera nul dans la situation suivante.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Considérons les blocs associés aux variables X et Y d'un ensemble de données D tel que","category":"page"},{"location":"","page":"Home","title":"Home","text":"D = (XYZ) avec X in R^np_X Y in R^np_Y Z in R^np_Z","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nX  = beta_X 1Z + epsilon_X \nY  = beta_Y 1Z + epsilon_Y\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"alors le bloc P_XY est nul si epsilon_X et epsilon_Y sont indépendants ie si la matrice de corrélation de epsilon_X avec epsilon_Y est nulle.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Du coup on applique les  permutations aux résidus epsilon_X et/ou epsilon_Y. Pour faire ça, on a d'abord besoin d'estimer le modèles linéaire (c'est ici qu'on utilise l'estimation avec SCAD), de récupérer les résidus, de les permuter puis de reconstruire les données corresopndant aux résidus permutés (-> fonction permute.conditional)","category":"page"},{"location":"","page":"Home","title":"Home","text":"  permute.conditional = function(y,n,data.complement,estimation){ # uses SCAD/OLS\n    permutation = sample(n)\n    \n    # SCAD/OLS estimaytion\n    fitted = switch(estimation, \n                    LM=lm.fit(cbind(1,data.complement),y)$fitted,\n                    SCAD=apply(y,2,SCADmod,x=data.complement,lambda=2*sqrt(var(y[,1])*log(ncol(data.complement))/nrow(data.complement))))\n    \n    residuals = y - fitted\n    \n    result = fitted + residuals[permutation,]\n    return(result) \n  }","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pour finir le test, on a besion d'esitmer les matrices de précision associées aux permutations (-> fonction stat.test)","category":"page"},{"location":"","page":"Home","title":"Home","text":"  stat.test = function(block1.perm,block2,data.orig,points.x,points.y){\n    data.orig[,points.x] = block1.perm\n    PrecMat = PrecXia(data.orig)\n    #Rhohat = cor(block1,block2,method='pearson')\n    #Rohat.std = Rhohat^2/(1-Rhohat^2)\n    submat = PrecMat$TprecStd[points.x,points.y]\n    return(sum(submat)^2) # We use the Xia estimator for the precision matrix\n  }","category":"page"}]
}
